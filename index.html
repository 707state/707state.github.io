<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-LinuxProcess-go进程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/24/LinuxProcess-go%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-12-23T16:14:30.000Z" itemprop="datePublished">2023-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/24/LinuxProcess-go%E8%BF%9B%E7%A8%8B/">LinuxProcess/go进程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h1><h2 id="进程锁"><a href="#进程锁" class="headerlink" title="进程锁"></a>进程锁</h2><p>进程锁不同于线程锁，互斥量，读写锁，自旋锁。它是通过记录一个PID文件，避免两个进程同时运行的文件锁。  </p>
<p>进程锁的主要作用之一就是协调进程的运行。<br>使用PID文件锁的另一个好处就是方便进程向自己发停止或者重启信号。</p>
<h2 id="使用进程锁"><a href="#使用进程锁" class="headerlink" title="使用进程锁"></a>使用进程锁</h2><p>其实要实现一个进程锁很简单,通过文件就可以实现了。例如程序开始运行时去检查一个PID文件,如果文件存在就直接退出,如果文件不存在就创建一个,并把当前进程的PID写入文件中。这样我们很容易可以实和读锁,但是所有流程都需要自己控制。 </p>
<h2 id="使用flock"><a href="#使用flock" class="headerlink" title="使用flock"></a>使用flock</h2><p>go引入了FcntlFock()</p>
<h1 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h1><p>orphan process。其父进程完成后或被终止后仍继续运行的一类进程。<br>也就是父进程结束但是子进程还在运行，如同孤儿。孤儿进程的父进程会被init收养。<br>作用：现实中用户可能使进程可以成为孤儿进程，这样她就于父进程session脱离，成为守护进程。</p>
<h1 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h1><p>一个进程完成工作终止之后，他的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。<br>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然在系统里，这样的进程称为僵尸进程。</p>
<h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><p>Daemon，可以认为守护进程就是后台服务进程，因为她有一个很长的生命周期提供服务，关闭终端不会影响服务。</p>
<h2 id="实现守护进程"><a href="#实现守护进程" class="headerlink" title="实现守护进程"></a>实现守护进程</h2><p>首先保证进程在后台运行，可以在启动程序后卖弄加&amp;。更原始的方法是进程自己fork然后结束父进程。<br>然后于终端、进程组、会话分离。每个进程创建时都绑定一个终端而且属于一个进程组。这些进程组在一个会话中。想要与环境分离可以使用setsid()。也可以从父进程集成文件掩码，手动清理掩码(umask)。</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>pipe是最简单的方式，任何进程的标准输出都可以作为其他进程的输出</p>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>见后面</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>在内核部分实现，原理类似于传统的消息队列</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>shared memory</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>本质上是一个整型计数器，调用wait时计数-1，减到0开始阻塞进程，从而达到进程，线程间协作的作用。</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>通过网络来通信。</p>
<h1 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h1><h2 id="信号种类"><a href="#信号种类" class="headerlink" title="信号种类"></a>信号种类</h2><p>Linux中有多种信号，1-31为unix支持的信号，是不可靠信号，32-63是扩充信号，叫可靠信号。前者不支持排队，可能会丢失。<br>go将信号封装在os&#x2F;signal中。  </p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>启动一个进程，需要调用操作系统的调用(syscall)，实际上操作系统和普通进程是运行在不同空间上的，操作系统进程运行在内核态(todo:kernel space)，开发者运行得进程在用户态，有效规避了用户程序破坏系统的可能。</p>
<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>内核给每个访问的文件分配了文件描述符，本质是一个非负整数，在打开或新建文件是返回，以后读写文件都依靠这个文件描述符。<br>socket连接也是文件。</p>
<h1 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Epoll是poll的改进版，更加高效，与高并发有关。</p>
<h2 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h2><p>本质上是poll本质上是Linux系统调用，其接口为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd *fds,nfds_t nfds,int timeout)</span><br></pre></td></tr></table></figure>
<p>作用：监控资源是否可用</p>
<h2 id="Epoll-1"><a href="#Epoll-1" class="headerlink" title="Epoll"></a>Epoll</h2><p>epoll大幅提升高并发服务器的资源使用率，相比poll而言。epoll只查询内核IO事件唤醒的集合。还提供edge triggered的特性。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>epoll是基于文件描述符的callback函数来实现的，只有发生IO时间的socket会调用callback函数，然后加入epoll的Ready队列。</p>
<h2 id="Mmap"><a href="#Mmap" class="headerlink" title="Mmap"></a>Mmap</h2><p>epoll使用mmap来共享内存。<br>mmap不是进程的概念，这是一种共享内存的方法。go的设计宗旨是”不要通过共享来通信，通过通信来共享”。</p>
<h1 id="共享内存-1"><a href="#共享内存-1" class="headerlink" title="共享内存"></a>共享内存</h1><p>实现mmap()函数支持共享内存，不过是调用的c实现的系统调用函数。</p>
<h1 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h1><p>一般我们运行程序都是Fork一个进程后马上执行Exec加载程序,而Fork的是否实际上用的是父进程的堆栈空间,Linux通过Copy On Write技术极大地减少了Fork的开销。  </p>
<h1 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h1><p>全称Control Groups，是Linux内核用于资源隔离的技术。Cgroups可以控制CPU，内存，磁盘访问。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>Cgroups有一个特殊的数据结构记录进程组的信息。<br>Docker的两个基础是Cgroups和Namespaces。</p>
<h1 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h1><p>隔离命名空间，限制了容器之间的进程通信。<br>Linux内核提供了clone系统调用，用clone取代fork就能创建同一命名空间下的进程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/24/LinuxProcess-go%E8%BF%9B%E7%A8%8B/" data-id="clqi9htla0000u0cxbycdb93t" data-title="LinuxProcess/go进程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LinuxProcess-基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/24/LinuxProcess-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2023-12-23T16:12:10.000Z" itemprop="datePublished">2023-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/24/LinuxProcess-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">LinuxProcess/基础知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>已运行程序的实体，进程需要一些资源才能完成工作。<br>进程不一定都是在运行的，也可能在等待调度。</p>
<h2 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h2><p>全称为Process ID，是标示和区分进程的ID，他是全局唯一的正整数。<br>在Go可以用Getpid()获得进程PID。<br>可以看到PID是有操作系统随机分配的，同一个程序运行两次会产生两个PID。</p>
<h2 id="PPID"><a href="#PPID" class="headerlink" title="PPID"></a>PPID</h2><p>每个进程不仅有PID还会有PPID，即父进程ID。<br>这是因为进程都是有父进程衍生出来的。PID为1的进程是内核创建的init进程，所以该进程没有父进程。<br>Go有Getppdi()  </p>
<h2 id="使用PID"><a href="#使用PID" class="headerlink" title="使用PID"></a>使用PID</h2><p>查看进程的PID可以用top&#x2F;ps</p>
<h3 id="TOP"><a href="#TOP" class="headerlink" title="TOP"></a>TOP</h3><p>可以看到当前的进程，并获取更具体的PID</p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>执行ps aux</p>
<h2 id="使用PID-1"><a href="#使用PID-1" class="headerlink" title="使用PID"></a>使用PID</h2><p>有了pid就可以用kill结束进程。  </p>
<h1 id="进程名字"><a href="#进程名字" class="headerlink" title="进程名字"></a>进程名字</h1><p>进程名是进程参数的第一个字符串，一般可以用os.Args获取。  </p>
<h1 id="进程参数"><a href="#进程参数" class="headerlink" title="进程参数"></a>进程参数</h1><p>任何进程启动时都可以赋予一个字符串数组作为参数，一般叫Argv或Args。  </p>
<h2 id="获得进程Argument"><a href="#获得进程Argument" class="headerlink" title="获得进程Argument"></a>获得进程Argument</h2><p>进程参数可以分两类：Argument(参数)也就是作为进程运行的实体参数。<br>Go可以用os.Args获取命令行参数，即os.Args[1:]就是所需输入的。  </p>
<h2 id="获得进程flag"><a href="#获得进程flag" class="headerlink" title="获得进程flag"></a>获得进程flag</h2><p>使用Flag可以将命令行参数转化成所需要的数据类型</p>
<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><h2 id="进程输入与输出"><a href="#进程输入与输出" class="headerlink" title="进程输入与输出"></a>进程输入与输出</h2><p>每个进程，操作系统都会分配三个文件资源，分别是标准输入STDIN，标准输出STDOUT，错误输出STDERR。  </p>
<h2 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h2><p>来自管道的数据也是标准输入的一种。这就可以用io.Readall来获取。</p>
<h2 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h2><p>fmt.Printxx</p>
<h1 id="Concurrently-Parallel"><a href="#Concurrently-Parallel" class="headerlink" title="Concurrently Parallel"></a>Concurrently Parallel</h1><p>这两者是不同的概念，并行是实现并发的一种。</p>
<h1 id="进程越多越好？"><a href="#进程越多越好？" class="headerlink" title="进程越多越好？"></a>进程越多越好？</h1><p>Nginx是一个高性能、高并发的Web服务器,也就是说它可以同时处理超过10万个HTTP请求,而它建议的启动的进程数不要超过CPU个数,为什么呢?<br>Nginx是Master-Worker模型，Master进程只管负责Worker进程，worker进程负责处理真实的请求。每个worker进程能够处理的请求跟内存有关，因为Linux的Nginx使用了epoll这样的多路复用的IO接口，不需要多线程并行也能并发。<br>多进程的快出是CPU切换上下文时间变多。  </p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>进程数等于CPU数，但是进程有阻塞。这是应该提高进程数增加并发数。<br>在Nginx的例子中,如果Nginx主要负责静态内容的下载,而服务器内存比较小,大部分文件访问都需要读磁盘,这时候进程很容易阻塞,所以建议提高下Worker数目。 </p>
<h1 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h1><p>nginx可以在配置文件里面知名COU，减少上下文切换。  </p>
<h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p>在Linux源码fs&#x2F;proc&#x2F;array.c里面，定义了7种状态。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>O:进程正在处理器运行,这个状态从来没有见过.<br>S:休眠状态(sleeping)<br>R:等待运行(runable)R Running or runnable (on run queue) 进程处于运行或就绪状态<br>I:空闲状态(idle)<br>Z:僵尸状态(zombie)<br>T:跟踪状态(Traced)<br>B:进程正在等待更多的内存页<br>D: 不可中断的深度睡眠,一般由IO引起,同步IO在做读或写操作时,cpu不能做其它事情,只能等待,这时进程处于这种状态,如果程序采用异步IO,这种状态应该就很少见到了。 </p>
<h1 id="退出码"><a href="#退出码" class="headerlink" title="退出码"></a>退出码</h1><p>人和进程退出是都会留下退出码。0-255.0表示正常退出。<br>这个东东在bash脚本很常见，根据前一个命令的退出吗选择是否执行下一个</p>
<h1 id="进程资源"><a href="#进程资源" class="headerlink" title="进程资源"></a>进程资源</h1><p>查看PID为1的进程信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /proc/1/</span><br></pre></td></tr></table></figure>
<p>同样的可以在这里查看&#x2F;proc&#x2F;1&#x2F;status</p>
<p>实际上ps命令获得的数据就是查看proc文件夹的内容获得的</p>
<h1 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h1><p>一个进程拿着资源A请求资源B，另一个进程拿着资源B请求资源A，双方都不释放自己的资源，导致两个进程都进行不下去。  </p>
<h1 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h1><p>进入活锁的进程是没有阻塞的，会继续使用CPU，但外界看到整个进程没有进行。  </p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>两个人同时过独木桥，两个人都让对方，这就是活锁<br>活锁会导致CPU耗尽，解决方法是引入随机变量、增加重试次数等。  </p>
<h1 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h1><p>Portable Operation System Interface</p>
<p>操作系统的接口标准，Unix, Linux, Mac遵循这套标准。  </p>
<h2 id="POSIX进程"><a href="#POSIX进程" class="headerlink" title="POSIX进程"></a>POSIX进程</h2><p>有POSIX定的fork和exec创建起一个POSIC进程，这个进程可以使用通用的IPC，信号等机制。  </p>
<h2 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h2><p>POSIX定义了线程的标准，包括创建和控制线程的API，在pthreads中实现</p>
<h1 id="Nohup"><a href="#Nohup" class="headerlink" title="Nohup"></a>Nohup</h1><p>普通进程运行时会默认绑定在TTY，关闭后会给上面的所有线程发送TERM信号。<br>Nohup原理就是在此终端关闭时给该终端下的每一个进程发送SIGHUP信号，但是nuhup会忽略这个信号。<br>这是运行守护进程最简单的方法。</p>
<h1 id="运行进程"><a href="#运行进程" class="headerlink" title="运行进程"></a>运行进程</h1><p>系统调用，利用系统提供的fork和exec接口</p>
<h1 id="衍生新进程"><a href="#衍生新进程" class="headerlink" title="衍生新进程"></a>衍生新进程</h1><p>可以类比erlang的spawn，能够执行任意go或者非go程序，等待返回结果，外部进程结束后继续执行本程序。<br>go提供了eexec.Command来执行其他程序。  </p>
<h1 id="执行外部程序"><a href="#执行外部程序" class="headerlink" title="执行外部程序"></a>执行外部程序</h1><p>把新程序加载到自己的内存里。<br>执行外部程序不会返回到原进程中。<br>应用的机制是syscall这个包</p>
<h1 id="复制进程"><a href="#复制进程" class="headerlink" title="复制进程"></a>复制进程</h1><p>go没有提供复制父进程的堆栈空间的接口，事实上spawn, exec都是调用的Fork</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/24/LinuxProcess-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="clqi9htlh0001u0cxfe4qclef" data-title="LinuxProcess/基础知识" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-HTTP-day4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/24/HTTP-day4/" class="article-date">
  <time class="dt-published" datetime="2023-12-23T16:09:17.000Z" itemprop="datePublished">2023-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/24/HTTP-day4/">HTTP/day4</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="安全的HTTP"><a href="#安全的HTTP" class="headerlink" title="安全的HTTP"></a>安全的HTTP</h1><p>HTTP协议可能有信息窃听或身份伪装的问题。</p>
<h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><p>不足之处：<br>1.使用明文通信，不加密<br>2.不验证通信方的身份，有可能遭遇伪装<br>3。无法证明报文的完整性。</p>
<h3 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h3><p>HTTP本身不具备加密功能。  </p>
<h4 id="TCP-IP是可能被窃听的网络"><a href="#TCP-IP是可能被窃听的网络" class="headerlink" title="TCP&#x2F;IP是可能被窃听的网络"></a>TCP&#x2F;IP是可能被窃听的网络</h4><h4 id="通信的加密"><a href="#通信的加密" class="headerlink" title="通信的加密"></a>通信的加密</h4><p>HTTP没有加密但是可以和SSL组合使用，加密HTTP的通信内容。<br>SSL与HTTP组合叫HTTPS  </p>
<h4 id="内容的加密"><a href="#内容的加密" class="headerlink" title="内容的加密"></a>内容的加密</h4><p>客户端在加密报文后进行发送。</p>
<h3 id="不验证身份"><a href="#不验证身份" class="headerlink" title="不验证身份"></a>不验证身份</h3><h4 id="任何人都可以发起请求"><a href="#任何人都可以发起请求" class="headerlink" title="任何人都可以发起请求"></a>任何人都可以发起请求</h4><p>服务器不存在确认通信方的处理步骤，因此存在隐患。<br>1.无法确定请求发送到目标的服务器是否按镇示意图返回响应。<br>2.无法确定响应返回的客户端是否按照安真实意图接收响应。<br>3.无法判断通信方的权限。<br>4.无法阻止海量请求下的DoS攻击。</p>
<h4 id="查明对手的证书"><a href="#查明对手的证书" class="headerlink" title="查明对手的证书"></a>查明对手的证书</h4><p>SSL使用一种被称为证书的手段可以确定通信方。  </p>
<h3 id="无法证明报文的完整性"><a href="#无法证明报文的完整性" class="headerlink" title="无法证明报文的完整性"></a>无法证明报文的完整性</h3><h4 id="接收到的内容可能有误"><a href="#接收到的内容可能有误" class="headerlink" title="接收到的内容可能有误"></a>接收到的内容可能有误</h4><p>中间人攻击</p>
<h4 id="如何防止篡改"><a href="#如何防止篡改" class="headerlink" title="如何防止篡改"></a>如何防止篡改</h4><h2 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+加密+认证+完整性保护&#x3D;HTTPS"></a>HTTP+加密+认证+完整性保护&#x3D;HTTPS</h2><p>HTTPS并非新协议, 而是在通信接口部分用SSL和TLS替代。</p>
<h3 id="互相交换密钥的公开密钥加密技术"><a href="#互相交换密钥的公开密钥加密技术" class="headerlink" title="互相交换密钥的公开密钥加密技术"></a>互相交换密钥的公开密钥加密技术</h3><p>SSL采用公开密钥加密的方式。  </p>
<h4 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h4><p>加密和解密共用同一个密钥的方式叫共享密钥加密，又叫对陈密钥加密。<br>存在安全转交密钥的问题。  </p>
<h4 id="使用两把密钥的加密"><a href="#使用两把密钥的加密" class="headerlink" title="使用两把密钥的加密"></a>使用两把密钥的加密</h4><p>一对非对称的密钥，一把叫私有密钥，一把叫公开密钥。发送密文一方使用对方的公开密钥，对方接收到被加密信息后再使用自己的私有密钥进行解密。</p>
<h4 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h4><p>HTTPS采用混合加密机制。在交换密钥环节使用公开密钥加密方式,之后的建立通信交换报文阶段则使用共享密钥加密方式。  </p>
<h3 id="证明公开密钥正确性的证书"><a href="#证明公开密钥正确性的证书" class="headerlink" title="证明公开密钥正确性的证书"></a>证明公开密钥正确性的证书</h3><h4 id="证明组织真实性的EV-SSL证书"><a href="#证明组织真实性的EV-SSL证书" class="headerlink" title="证明组织真实性的EV SSL证书"></a>证明组织真实性的EV SSL证书</h4><h4 id="确认客户端的客户端证书"><a href="#确认客户端的客户端证书" class="headerlink" title="确认客户端的客户端证书"></a>确认客户端的客户端证书</h4><h4 id="由子认证机构颁发的自签名证书"><a href="#由子认证机构颁发的自签名证书" class="headerlink" title="由子认证机构颁发的自签名证书"></a>由子认证机构颁发的自签名证书</h4><p>关键字：OpenSSL</p>
<h3 id="HTTPS的安全通信机制"><a href="#HTTPS的安全通信机制" class="headerlink" title="HTTPS的安全通信机制"></a>HTTPS的安全通信机制</h3><p>步骤1：客户端发送Client Hello报文开始SSL通信，包含客户端支持的SSL版本，加密组件列表。<br>步骤2：服务器使用SSL通信时，会以Server Hello报文作为应答，报文中包含SSL版本，加密组件。服务器的加密组件内容是从接收到的客户端加密组建筛选出来的。<br>步骤3：服务器发送Certificate报文。包含公开密钥证书。<br>步骤4：服务器发送Server Hello Done报文通知客户端，SSK握手协商结束。<br>步骤5：SSL第一次握手结束后，客户端以Client Key Exchange报文作为回应，报文中包含通信加密中使用的一种被称为Pre-master secret的随机密码串。<br>步骤6：客户端发送Change Cipher Spec报文，该报文会提示服务器，此后的通信采用Pre-master secret密钥加密。<br>步骤7：客户端发送的Finished报文，该报文包括至今全部报文的整体校验值。以服务器能否正确解密该报文为协商成功的标志。<br>步骤8：服务器发送同样的Change Cipher Spec报文。<br>步骤9：服务器发送Finished报文。<br>步骤10：服务器端和客户端的Finished报文交换完毕之后，SSL连接就算建立为那成。从此处就开始发送HTTP请求。<br>步骤11：应用层协议通讯，发送HTTP请求。<br>步骤12：最后由客户端断开连接，发送close_notify报文。<br>上述流程中，应用层发送数据会附加一种叫MAC(Message Authentication Code)的报文摘要，判断报文是否被篡改，保护报文的完整性。<br>这个过程中,先进行TCP三次握手,再进行TLS四次握手.</p>
<h4 id="SSL和TLS"><a href="#SSL和TLS" class="headerlink" title="SSL和TLS"></a>SSL和TLS</h4><p>SSL(Secure Socket Layer)和TLS(Transport Layer Security)两个协议。<br>问题：使用SSL会使处理速度变慢，包括通信慢和消耗大量资源的慢。另一种是SSL必须加密，会消耗更多的硬件资源。<br>SSL加速器(专用服务器)<br>HTTPS和HTTP各有用处.</p>
<h1 id="认证机制"><a href="#认证机制" class="headerlink" title="认证机制"></a>认证机制</h1><h2 id="何为认证"><a href="#何为认证" class="headerlink" title="何为认证"></a>何为认证</h2><p>核对信息:<br>密码,动态令牌,数字证书,生物认证,IC卡等<br>HTTP使用的认证方式:<br>BASIC认证,DIGEST认证,SSI客户认证,FormBase认证  </p>
<h2 id="BASIC认证"><a href="#BASIC认证" class="headerlink" title="BASIC认证"></a>BASIC认证</h2><p>步骤1:需要请求的资源需要BASIC认证时,服务器岁状态码401,返回<a target="_blank" rel="noopener" href="http://www.authentication首部字段的响应,该字段包含认证的方式以及request/">www.Authentication首部字段的响应,该字段包含认证的方式以及Request</a> URI安全域字符串<br>步骤2:客户端为了验证,将用户ID和密码发送给服务器,发送内容用用户ID和密码以:连接经过base64编码处理.<br>步骤3:接收到首部字段Authentication的服务器会对认证消息的正确性进行检验,如果认证通过就返回资源.  </p>
<h2 id="DIGEST认证"><a href="#DIGEST认证" class="headerlink" title="DIGEST认证"></a>DIGEST认证</h2><p>补充了BASIC认证缺乏的特性.</p>
<h2 id="SSL客户端认证"><a href="#SSL客户端认证" class="headerlink" title="SSL客户端认证"></a>SSL客户端认证</h2><h3 id="认证步骤"><a href="#认证步骤" class="headerlink" title="认证步骤"></a>认证步骤</h3><p>步骤1：接收到需要认证的请求，服务器会发送Certificate Request保文，要求客户端提供客户端证书。<br>步骤2：用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate保文方式发送给服务器。<br>步骤3：服务器验证客户端证书验证通过后方可领取客户端的公开密钥，然后开始加密通信。  </p>
<h2 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h2><p>基于表单的认证方法不是HTTP协议定义的。多数情况下，输入登录信息后，发送给Web应用程序，基于认证结果来决定认证是否成功。<br>基于表单认证使用最广泛。</p>
<h3 id="Session管理和Cookie应用"><a href="#Session管理和Cookie应用" class="headerlink" title="Session管理和Cookie应用"></a>Session管理和Cookie应用</h3><p>步骤1：客户端把用户ID和密码等登录纤细放进保文的实体部分，通常是以POST方法把请求发送给服务器，这时候会使用HTTPS通信来对表单画面的显示和用户输入数据的发送。<br>步骤2：服务器发送用以识别用户的Session ID，通过验证从客户端发送过来的登录信息进行身份验证，然后把用户的认证状态和Session ID绑定后记录在服务器端。向客户端返回响应是，会在首部字段Set-Cookie写入Session ID。<br>步骤3：客户端接收到Session ID后，会将其作为Cookie保存在本地。下一次吸纳个服务器发送请求就可以自动发送Cookie，所以Session ID随之发送到服务器。<br>一种安全的保存方法是：先利用给密码加盐(salt)的方式增加额外信息，在使用hash函数计算出散列值后保存。</p>
<h1 id="新增功能的协议"><a href="#新增功能的协议" class="headerlink" title="新增功能的协议"></a>新增功能的协议</h1><h2 id="消除HTTP瓶颈的SPDY"><a href="#消除HTTP瓶颈的SPDY" class="headerlink" title="消除HTTP瓶颈的SPDY"></a>消除HTTP瓶颈的SPDY</h2><p>造成瓶颈的标准：一条连接只能发送一个请求，请求只能从客户端开始。客户端不可以接收除响应以外的指令，请求&#x2F;响应未经压缩就发送，延迟大，发送冗长的首部，非强制压缩发送。<br>Ajax的解决方法：利用JavaScript和DOM操作，达到局部Web页面替换的异步通信手段。核心是XMLHttpRequest。但是会产生大量的请求，没有解决HTTP协议本身的问题。<br>Comet的解决方法：一旦服务端更新，Comet不让请求等待而是直接返回响应，这是一种通过延迟应答，模拟式先付武器断向客户端推送的功能(Server Push)。但是为了实现推送功能，Comet会将响应置于挂起状态，当服务器端更新是返回该响应，因此消耗了维持链接的资源。  </p>
<p>SPDY协议：在TCP&#x2F;IP的应用层和运输层之间通过新增会话层的形式运作，允许SSL。(处于SSL和HTTP之间)<br>使用SPDY后，将获得以下功能：<br>1.多路复用流：单一TCP链接就能够无限制处理HTTP请求，所有请求在一条TCP连接完成。<br>2.赋予请求优先级：无限制并发之外，能够逐个分配优先级顺序，解决因带宽底导致的响应变慢。<br>3.压缩HTTP首部：减少数据包的数量和字节数。<br>4.推送功能：服务器主动向客户端推送数据，不必等客户端的请求。<br>5.服务器提示功能：类似于4，避免发送不必要的请求。  </p>
<h2 id="使用浏览器进行全双工通信的WebSocket"><a href="#使用浏览器进行全双工通信的WebSocket" class="headerlink" title="使用浏览器进行全双工通信的WebSocket"></a>使用浏览器进行全双工通信的WebSocket</h2><p>解决Ajax和Comet里XMLHttpRequest的缺陷。</p>
<h3 id="WebSocket-Protocol"><a href="#WebSocket-Protocol" class="headerlink" title="WebSocket Protocol"></a>WebSocket Protocol</h3><p>建立在HTTP协议之上，发起点仍然是客户端，一旦确立连接，任意一方都能够发送信息。  </p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>推送功能，减少通信量(HTTP连接建立后只需要一次握手)。</p>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h2><p>围绕着七项技术进行讨论：<br>压缩：SPDY，Friendly<br>多路复用：SPDY<br>TLS义务化：speed+mobility<br>协商：speed…<br>client pull&#x2F;server push：speed<br>流量控制：SPDY<br>WebSocket：Speed</p>
<h2 id="Web服务器管理文件的WebDAV"><a href="#Web服务器管理文件的WebDAV" class="headerlink" title="Web服务器管理文件的WebDAV"></a>Web服务器管理文件的WebDAV</h2><p>基于万维网的分布式创作和版本控制，可对Web服务器的内容进行文件复制，编辑等操作的分布式文件系统。  </p>
<h3 id="拓展HTTP-1-1的WebDAV"><a href="#拓展HTTP-1-1的WebDAV" class="headerlink" title="拓展HTTP&#x2F;1.1的WebDAV"></a>拓展HTTP&#x2F;1.1的WebDAV</h3><p>对服务器的资源引入了概念：<br>集合：统一管理多个资源的概念。<br>资源：文件或集合叫资源<br>属性：定义资源的属性，定义以kv形式执行。<br>锁：设置文件状态。</p>
<h3 id="WebDAV新增方法和状态码"><a href="#WebDAV新增方法和状态码" class="headerlink" title="WebDAV新增方法和状态码"></a>WebDAV新增方法和状态码</h3><p>PROPFIND:获取属性<br>PROPPATCH：修改属性<br>MKCOL：创建集合<br>…<br>新增状态码：102 PROCESSING<br>207 MULTI-STATUS<br>…</p>
<h1 id="构建Web"><a href="#构建Web" class="headerlink" title="构建Web"></a>构建Web</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML构建了几乎全部Web页面"><a href="#HTML构建了几乎全部Web页面" class="headerlink" title="HTML构建了几乎全部Web页面"></a>HTML构建了几乎全部Web页面</h3><p>HTML是一种标记语言，被浏览器渲染为Web页面。  </p>
<h3 id="设计应用CSS"><a href="#设计应用CSS" class="headerlink" title="设计应用CSS"></a>设计应用CSS</h3><p>指定如何展现HTML的各种元素，理念是文档的结构和设计分离。<br>选择器的世界。</p>
<h2 id="动态HTML"><a href="#动态HTML" class="headerlink" title="动态HTML"></a>动态HTML</h2><p>JavaScript使HTML动态改变，DOM可以指定要改变的HTML元素</p>
<h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p>common gateway interface指Web服务器接受到请求后转发给程序的一组机制。通常由Perl, php,ruby, c编写。</p>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>JavaEE的一部分，运行环境叫做Web容器。</p>
<h2 id="数据发布的格式"><a href="#数据发布的格式" class="headerlink" title="数据发布的格式"></a>数据发布的格式</h2><h3 id="可拓展标记语言"><a href="#可拓展标记语言" class="headerlink" title="可拓展标记语言"></a>可拓展标记语言</h3><p>XML是一种可以扩展的标记语言，都是有SGML简化而成。从XML读取数据比HTML简单，更容易解析。   </p>
<h3 id="RSS-Atom"><a href="#RSS-Atom" class="headerlink" title="RSS&#x2F;Atom"></a>RSS&#x2F;Atom</h3><p>RSS简易信息聚合，Atom供稿格式</p>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>数据标记语言，常用于信息交换</p>
<h1 id="攻击站点的技术"><a href="#攻击站点的技术" class="headerlink" title="攻击站点的技术"></a>攻击站点的技术</h1><h2 id="针对Web的攻击"><a href="#针对Web的攻击" class="headerlink" title="针对Web的攻击"></a>针对Web的攻击</h2><h3 id="HTTP不具备必要的安全功能"><a href="#HTTP不具备必要的安全功能" class="headerlink" title="HTTP不具备必要的安全功能"></a>HTTP不具备必要的安全功能</h3><p>HTTP只是单纯的协议机制，安全方面较为劣势。</p>
<h3 id="在客户端即可篡改请求"><a href="#在客户端即可篡改请求" class="headerlink" title="在客户端即可篡改请求"></a>在客户端即可篡改请求</h3><h4 id="主动攻击"><a href="#主动攻击" class="headerlink" title="主动攻击"></a>主动攻击</h4><p>攻击者通过直接访问Web应用，把代码传入的攻击方式。直接对服务器资源进行攻击，代表：SQL注入和OS命令注入攻击。  </p>
<h4 id="被动攻击"><a href="#被动攻击" class="headerlink" title="被动攻击"></a>被动攻击</h4><p>利用圈套策略，攻击者不直接对Web应用访问发起攻击。<br>步骤1：用户触发已设置好的陷阱，陷阱会启动发送已嵌入攻击代码的HTTP请求。<br>步骤2：用户中招后，用户的浏览器或邮件客户端触发。<br>步骤3：用户浏览起把含有攻击代码的HTTP发送给攻击目标的Web程序。<br>步骤4：执行完，该程序成为跳板。<br>代表性攻击(XSS)跨站脚本攻击和跨站点请求伪造。  </p>
<h3 id="因输出值转义不完全引发的安全漏洞"><a href="#因输出值转义不完全引发的安全漏洞" class="headerlink" title="因输出值转义不完全引发的安全漏洞"></a>因输出值转义不完全引发的安全漏洞</h3><p>实施Web应用的安全对策：<br>1.客户端的验证<br>2.Web应用端的验证<br>Web应用端的输入值验证是检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策。  </p>
<h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>XSS 是攻击者利用预先设置的陷阱触发的被动攻击<br>可能会窃取用户Cookie</p>
<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>SQL 注入是攻击者将 SQL 语句改变成开发者意想不到的形式以达到破坏结构的攻击。 </p>
<h4 id="OS注入攻击"><a href="#OS注入攻击" class="headerlink" title="OS注入攻击"></a>OS注入攻击</h4><p>通过Web执行非法的操作系统命令达到攻击的目的。只要能调用shell就有被攻击的风险</p>
<h4 id="HTTP首部攻击"><a href="#HTTP首部攻击" class="headerlink" title="HTTP首部攻击"></a>HTTP首部攻击</h4><p>攻击者在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/24/HTTP-day4/" data-id="clqi9bn6t00017ccx1m7v7q6t" data-title="HTTP/day4" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="http/day3-HTTP-day3" class="h-entry article article-type-http/day3" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/24/HTTP-day3/" class="article-date">
  <time class="dt-published" datetime="2023-12-23T16:07:34.000Z" itemprop="datePublished">2023-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/24/HTTP-day3/">HTTP/day6</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="报文内的http信息"><a href="#报文内的http信息" class="headerlink" title="报文内的http信息"></a>报文内的http信息</h1><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>HTTP协议交互的信息叫做报文，客户端叫请求报文，服务器端叫响应报文。  </p>
<h2 id="请求报文和响应报文的结构"><a href="#请求报文和响应报文的结构" class="headerlink" title="请求报文和响应报文的结构"></a>请求报文和响应报文的结构</h2><p>由请求行(包含请求方法，url和http版本)，状态行(包含状态码，原因短语和HTTP版本)，首部字段(包含请求和响应的各种条件和属性的各类首部)，还可能有HTTP的RFC里未定义的首部。  </p>
<h2 id="编码提升传输效率"><a href="#编码提升传输效率" class="headerlink" title="编码提升传输效率"></a>编码提升传输效率</h2><h3 id="报文主体和实体的差异"><a href="#报文主体和实体的差异" class="headerlink" title="报文主体和实体的差异"></a>报文主体和实体的差异</h3><p>报文：HTTP通信的基本单位，有8位组子节流组成，通过HTTP通信传输。<br>实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。<br>通常,报文主体等于实体主体。只有当传输中进行编码操作时,实体主体的内容发生变化,才导致它和报文主体产生差异。</p>
<h3 id="压缩传输的内容编码"><a href="#压缩传输的内容编码" class="headerlink" title="压缩传输的内容编码"></a>压缩传输的内容编码</h3><p>常见编码：gzip, compress, deflate, identity  </p>
<h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><p>在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示出页面。这种功能叫分块传输编码。<br>实体主体分成多个块，每个块都用16进制来标记块的大小，实体主体的最后一块使用”0(CR+LF)”标记。  </p>
<h2 id="发送多种数据的多部分对象集"><a href="#发送多种数据的多部分对象集" class="headerlink" title="发送多种数据的多部分对象集"></a>发送多种数据的多部分对象集</h2><p>多部分对象集合包含的对象如下：<br>1.multipart&#x2F;form-data：Web表单文件上传时使用。<br>2.multipart&#x2F;byteranges：响应报文包含多个范围的内容时使用。<br>HTTP报文使用多部分对象集合时需要在首部字段家生Content-type。  </p>
<h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><p>要实现该功能需要指定下载的实体范围。像这样,指定范围发送的请求叫做范围请求(Range Request)。 </p>
<h2 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h2><p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉,然后提供给客户端最适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。<br>有三种内容协商：服务器驱动协商(Server-driven Negotiation), 客户端驱动协商(Agent-driven Negotiation), 透明协商(Transparent Negotiation)。  </p>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p>状态码表示服务器响应请求的结果。</p>
<h2 id="告知请求结果"><a href="#告知请求结果" class="headerlink" title="告知请求结果"></a>告知请求结果</h2><p>借助状态码的值服务器端有没有正常处理请求。  </p>
<h2 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h2><p>2xx表示正常处理</p>
<h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>返回的报文不含实体的主体部分。</p>
<h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h3><p>客户端进行了范围请求，服务器成功响应。</p>
<h2 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h2><p>结果需要某些特殊处理才能正确处理请求。</p>
<h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>永久性重定向，需要用新的URI请求。</p>
<h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p>临时性重定向，以后还会改变。</p>
<h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>请求的资源存在另一个URI,应使用GET方法定向获取的资源。</p>
<h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>客户端发送附带条件的请求时，服务器允许请求访问资源但是没有满足条件。</p>
<h2 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h2><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>语法错误</p>
<h3 id="401-Unauthorised"><a href="#401-Unauthorised" class="headerlink" title="401 Unauthorised"></a>401 Unauthorised</h3><p>没有经过认证的认证信息。</p>
<h3 id="403Forbidden"><a href="#403Forbidden" class="headerlink" title="403Forbidden"></a>403Forbidden</h3><p>服务器拒绝。</p>
<h2 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h2><h3 id="501-Internal-Server-Error"><a href="#501-Internal-Server-Error" class="headerlink" title="501 Internal Server Error"></a>501 Internal Server Error</h3><p>服务器端执行请求发生错误。</p>
<h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>表明服务器暂时处于超负载或正在停机维护。</p>
<h1 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h1><p>一台 Web 服务器可搭建多个独立域名的 Web 网站,也可作为通信路径上的中转服务器提升传输效率。 </p>
<h2 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h2><p>HTTP允许一台HTTP服务器搭建多个Web站点。在相同的IP下，由于虚拟主机有多个主机名和域名的Web网站，因此发送HTTP请求时，要在Host首部完整指定主机名和域名的url。</p>
<h2 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a>通信数据转发程序</h2><p>代理，网关，隧道时用于通信数据转发的应用程序。<br>代理：一种有转发功能的应用程序，扮演了中间人的角色。<br>网关：转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，他就像自己拥有资源的源服务器一样对请求进行处理。<br>隧道：服务器和客户端之间中转，保持双方通信连接的应用程序。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理服务器的基本行为就是接受客户端发送的请求后转发给其他服务器。代理不改变URI，直接发送给前方持有资源的目标服务器。<br>持有资源实体的服务器被称为源服务器。<br>HTTP通信中可以联合多个代理服务器，请求和响应的转发会经过数个锁链一样的代理服务器，转发时，需要附加Via首部字段以标记主机信息。<br>使用代理服务器的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制。<br>两种基准：是否使用缓存，是否会修改报文。<br>1.缓存代理：转发响应时，缓存代理预先将资源的副本保存在代理服务器上，客户再次接受对相同资源的请求时，就直接将缓存作为响应返回。<br>2.透明代理：不对报文作任何加工。</p>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关能让通信线路上的服务器提供非HTTP协议。提高通信安全性, 可以连接数据库。</p>
<h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>可以使用SSL进行加密，目的是确保客户端能够与服务器进行安全的通信。</p>
<h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><p>利用缓存可以减少对源服务器的访问，节省了通信流量和通信时间。缓存服务器是代理服务器的一种。<br>优势是避免多次从源服务器转发资源。  </p>
<h3 id="缓存的有效期限"><a href="#缓存的有效期限" class="headerlink" title="缓存的有效期限"></a>缓存的有效期限</h3><p>涉及到缓存资源的有效性，如果源服务器数据更新而缓存没有就会出错。</p>
<h3 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h3><p>客户端和缓存服务器相同点都是缓存过期后,会向源服务器确认有效性。若失效则再次请求。</p>
<h1 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h1><h2 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h2><p>请求和响应的首部分别为处理请求和响应的必要信息。<br>请求报文：Method，URL，HTTP版本，首部字段组成。<br>响应报文：HTTP版本，状态码，HTTP首部字段组成。</p>
<h3 id="传递重要信息"><a href="#传递重要信息" class="headerlink" title="传递重要信息"></a>传递重要信息</h3><p>首部字段传递了报文主体大小，所使用语言，认证信息等内容。</p>
<h3 id="4种首部字段类型"><a href="#4种首部字段类型" class="headerlink" title="4种首部字段类型"></a>4种首部字段类型</h3><p>通用首部字段：请求和响应双方都要用<br>请求首部字段：客户端向服务器段发送时使用的首部。<br>响应首部：通上<br>实体首部：针对请求报文与响应报文的实体部分使用的首部。</p>
<h3 id="End-to-end首部和Hop-by-hop首部"><a href="#End-to-end首部和Hop-by-hop首部" class="headerlink" title="End-to-end首部和Hop-by-hop首部"></a>End-to-end首部和Hop-by-hop首部</h3><p>端到端：在此类别中的首部会转发给请求&#x2F;响应对应的最终接收目标，且必须保存在由缓存生成的响应，另外规定它必须被转发。<br>逐跳：只对单次转发有效，会因通过缓存或代理而不再转发。需要提供Connection字段。</p>
<h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>控制缓存的行为，</p>
<h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>程序不再转发给代理的首部字段<br>管理持久性连接<br>控制不再转发给代理的首部字段</p>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>HTTP报文的日期和时间。</p>
<h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p>实现说明报文主体后记录那些首部字段。<br>…….略</p>
<h2 id="为Cookie服务的首部字段"><a href="#为Cookie服务的首部字段" class="headerlink" title="为Cookie服务的首部字段"></a>为Cookie服务的首部字段</h2><h2 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h2><p>由NAME, expires, oath, domain, decure等属性</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie:status&#x3D;enable<br>首部字段 Cookie 会告知服务器,当客户端想获得 HTTP 状态管理支持时,就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时,同样可以以多个 Cookie 形式发送。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/24/HTTP-day3/" data-id="clqi9bn6w00037ccxavvfbcvu" data-title="HTTP/day6" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-HTTP-day2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/24/HTTP-day2/" class="article-date">
  <time class="dt-published" datetime="2023-12-23T16:05:36.000Z" itemprop="datePublished">2023-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/24/HTTP-day2/">HTTP/day2.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h1><p>HTTP用于客户端和服务端之间的通信。  </p>
<h2 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h2><p>请求由客户端发出，服务器端响应并返回。<br>典型请求报文的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.htm HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br></pre></td></tr></table></figure>
<p>GET叫Method，index.htm指明请求的资源对象，也叫请求URL。最后的HTTP1.1为版本号。<br>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。<br>响应的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</span><br><span class="line"></span><br><span class="line">Content-Length: 362</span><br><span class="line">Content-Type: text/html</span><br><span class="line">&lt;html&gt;</span><br></pre></td></tr></table></figure>
<p>200 OK表示请求的处理结果的状态码和原因短语(reason-phrase)<br>日期之后时资源实体的主体(entity body)。  </p>
<h2 id="HTTP时不保存状态的协议"><a href="#HTTP时不保存状态的协议" class="headerlink" title="HTTP时不保存状态的协议"></a>HTTP时不保存状态的协议</h2><p>HTTP协议不具备保存之前发送的请求或响应的能力。这是为了更快的处理大量事务，确保协议的可伸缩性。<br>为了实现保持状态的功能引入了Cookie技术。  </p>
<h2 id="请求URI定位资源"><a href="#请求URI定位资源" class="headerlink" title="请求URI定位资源"></a>请求URI定位资源</h2><p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能,在互联网上任意位置的资源都能访问到。  </p>
<h2 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h2><p>GET：获取资源。GET方法用于请求访问已被URI识别的资源。<br>POST：传输实体主体。有安全性的考量。<br>PUT：传输文件。<br>HEAD：获得报文首段。<br>DELETE：删除文件。<br>OPTIONS：询问支持的方法。<br>TRACE：追踪路径。<br>CONNECT：要求用隧道协议连接代理(SSL和TLS)。  </p>
<h2 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h2><p>每次请求会造成无谓的浪费，增加通信量的开销。</p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>特点：任一方不提出断开就保持连接。<br>持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销,减轻了服务端的负载。另外,减少开销的那部分时间,使 HTTP 请求和响应能够更早地结束。</p>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>pipelining。时的不用等待响应就可以发送下一个请求，这样的并行发送多个请求了。  </p>
<h2 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h2><p>客户端自动的在请求报文加入Cookie值后发送出去。<br>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息,通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时,客户端会自动在请求报文中加入 Cookie 值后发送出去。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/24/HTTP-day2/" data-id="clqi9bn6v00027ccx8zjn436v" data-title="HTTP/day2.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-HTTP-day1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/24/HTTP-day1/" class="article-date">
  <time class="dt-published" datetime="2023-12-23T16:04:10.000Z" itemprop="datePublished">2023-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/24/HTTP-day1/">HTTP/day1.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="网络基础TCP-IP"><a href="#网络基础TCP-IP" class="headerlink" title="网络基础TCP&#x2F;IP"></a>网络基础TCP&#x2F;IP</h1><p>网络是运行在TCP&#x2F;IP协议族上的，而HTTP属于他内部的一个子集。  </p>
<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP&#x2F;IP协议族"></a>TCP&#x2F;IP协议族</h2><p>什么是协议：规定不同的硬件，不同的操作系统之间的通信的规则。<br>TCP&#x2F;IP是各类协议族的总称。  </p>
<h3 id="TCP-IP的分层管理"><a href="#TCP-IP的分层管理" class="headerlink" title="TCP&#x2F;IP的分层管理"></a>TCP&#x2F;IP的分层管理</h3><p>按从顶到底分4层：应用层，传输层，网络层和链路层。<br>作用：解耦和，便于改动内部设计。<br>各层次作用：<br>1.应用层：决定项用户提供应用服务时通信。FTP和DNS，HTTP。<br>2.传输层：对上层应用层,提供处于网络连接中的两台计算机之间的数据传输，有TCP和UDP两个协议。<br>3.网络层：处理在网络上流动的数据包。数据包时网络传输最小数据单位。<br>4.链路层：处理硬件部分，网卡，设备驱动，光纤等。  </p>
<h3 id="TCP-IP通信传输流"><a href="#TCP-IP通信传输流" class="headerlink" title="TCP&#x2F;IP通信传输流"></a>TCP&#x2F;IP通信传输流</h3><p>利用 TCP&#x2F;IP 协议族进行网络通信时,会通过分层顺序与对方进行通信。发送端从应用层下走,接收端则往应用层往上走。<br>用 HTTP 举例来说明,首先作为发送端的客户端在应用层(HTTP 协议)发出一个看某个 Web 页面的 HTTP 请求。接着,为了传输方便,在传输层(TCP 协议)把从应用层处收到的数据(HTTP 请求文)进行分割,并在各个报文上打上标记序号及端口号后转发给网络层。在网络层(IP 协议),增加作为通信目的地的 MAC 地址后转发给链路层。这样一来,往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据,按序往上层发送,一直到应用层。当传输到应层,才能算真正接收到由客户端发送过来的 HTTP 请求。<br>层与层之间传输数据，每经过一层会打上该层首部信息，接收端接受时层层拆包。这叫封装。  </p>
<h2 id="IP，TCP，DNS"><a href="#IP，TCP，DNS" class="headerlink" title="IP，TCP，DNS"></a>IP，TCP，DNS</h2><p>TCP&#x2F;IP 协议族中的 IP 指的就是网际协议。<br>IP 地址指明了节点被分配到的地址,MAC 地址是指网卡所属的固定地址。IP 地址可以和MAC 地址进行配对。IP 地址可变换,但 MAC 地址基本上不会更改。   </p>
<h3 id="ARP协议凭借MAC地址通信"><a href="#ARP协议凭借MAC地址通信" class="headerlink" title="ARP协议凭借MAC地址通信"></a>ARP协议凭借MAC地址通信</h3><p>IP间通信依赖MAC地址。每当中转时要利用中转设备的MAC地址搜索下一个中转目标。ARP是一种地址解析协议根据通信方IP查其MAC。  </p>
<h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>在到达通信目标前的中转过程中,那些计算机和路由器等网络设备只能获悉很粗略的传路线。<br>这种机制称为路由选择(routing)</p>
<h3 id="TCP：确保可靠"><a href="#TCP：确保可靠" class="headerlink" title="TCP：确保可靠"></a>TCP：确保可靠</h3><p>TCP：传输层，提供字节流服务。大块数据分隔成报文段，并且能确认数据能够送达。<br>方法：用 TCP 协议把数据包送出去后,TCP 不会对传送后的情况置之不理,它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志(flag) —— SYN(synchronize)和 ACK(acknowledgement)。<br>发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后,回传一个带有 SYN&#x2F;ACK 标志的数据包以示传达确认信息。最后,发送端再回传一个带 ACK 标志的数据包,表“握手”结束。若在握手过程中某个阶段莫名中断,TCP 协议会再次以相同的顺序发送相同的数据包。  </p>
<h2 id="DNS：负责域名解析"><a href="#DNS：负责域名解析" class="headerlink" title="DNS：负责域名解析"></a>DNS：负责域名解析</h2><p>与HTTP同位于应用层，提供域名地址到IP地址之间的解析服务。  </p>
<h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><p>URL就是浏览器访问web页面时需要输入的网页地址。</p>
<h3 id="URI（统一资源标识符）"><a href="#URI（统一资源标识符）" class="headerlink" title="URI（统一资源标识符）"></a>URI（统一资源标识符）</h3><p>Uniform Resource Identifier，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源使用的协议类型名称。<br>URL时URI子集，URL只是互联网上的地址，而 URI更接近一种格式。  </p>
<h3 id="URI格式"><a href="#URI格式" class="headerlink" title="URI格式"></a>URI格式</h3><p>绝对URI：使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写。最后附一个冒号(:)<br>登陆信息：指定用户名和密码作为从服务器端获取资源时必要的登录信息。<br>服务器地址：使用绝对 URI 必须指定待访问的服务器地址。<br>RFC：Request for Comments，不遵照RFC的服务器可能无法被访问。  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/24/HTTP-day1/" data-id="clqi9bn6o00007ccx1nl5eoy7" data-title="HTTP/day1.md" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法学习-5" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-5/" class="article-date">
  <time class="dt-published" datetime="2023-11-29T11:15:31.000Z" itemprop="datePublished">2023-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-5/">算法学习-5</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>图论，启动！<br>图由顶点和边组成，顶点代表对象，边表示两个对象的连接关系，顶点的集合是<br>$V$<br>边的集合是<br>$E$<br>的图记作<br>$G&#x3D;(V,E)$</p>
<p>边可以被赋予不同的属性，例如权重等。  </p>
<h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><p>相邻顶点的序列称为路径，起点和终点重合的路径叫圈，任意两点之间有路径连接的图叫连通图，顶点连接的边数叫做这个点的度。<br>没有圈连接的连通图叫做树，没有圈的非连通图叫做森林，一棵树的边数恰好是顶点数-1。  </p>
<h2 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h2><p>度分为入读出度，指进来的为入，指出去的为出。没有圈的有向图叫做DAG。图可以用邻接矩阵和邻接表来表示。</p>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵两种图都可以表示，要注意下标的关系。</p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>用于稀疏矩阵的储存，最简单得情况就可以用vector数组来储存，也可以用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct vertex&#123;</span><br><span class="line">    vector&lt;vectex*&gt; edge;</span><br><span class="line">&#125;;</span><br><span class="line">vertex G[max_n];</span><br></pre></td></tr></table></figure>
<p>例题·：二分图的判定（什么是二分图详见离散数学）<br>给定n顶点的图，问是否能最多用2中颜色进行染色？<br>给定的图是无向图，因此可以用邻接矩阵表示这个图。<br>理一理思路，我们知道怎么终止判断，也就是在遍历过程中，如果一个顶点被染色为1，而他的相邻点也被染色为1，就只这不是二分图。终点就是怎么在邻接矩阵&#x2F;表里面进行dfs。因此这一题的本质是考察无向图的表示和DFS（主要是图的表示形式），只给出n的个数是不够的。<br>代码如下：</p>
<pre><code>class Solution&#123;
    private:
    int n;//顶点数目
    vector&lt;int&gt; color;//每个顶点的染色
    bool valid;
    static constexpr UNCOLORED=0,RED=1,GREEN=2;
    public:
    void dfs(int node,int c,const vector&lt;vector&lt;int&gt;&gt;&amp; graph)&#123;//dfs触发条件是node顶点没有被染色
    color[node]=c;
    int node_color=(c==RED)?GREEN:RED;//更改继续染色的顶点要被染的色
    for(int neighbor:graph[node])&#123;//获取这一个点的相邻点
        if(color[neighbor]==UNCOLORED)&#123;
            dfs(neighbor,node_color,graph);
            if(!valid) return;
        &#125;else if(color[neighbor]!=node_color)&#123;//要被染色的顶点颜色与当前顶点一致
            valid=false;
            return;
        &#125;
    &#125;
    &#125;
    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp;graph)&#123;//graph[i]表示i顶点的相邻顶点的集合
        n=graph.size();
        color.resize(n,UNCOLORED);//全部顶点还没染色
        valid=1;//空图为二分图
        for(int i=0;i&lt;n;i++)&#123;
            if(color[i]==UNCOLORED)&#123;//这个节点没有被染色
                dfs(i,RED,graph);
            &#125;
        &#125;
        return valid;
    &#125;
&#125;;
时间复杂度是O(V+E)  

例题2：最短路问题  
给定两个顶点，求这两点之间通路的权值最小和。 

补充算法：  
1.Bellman-Ford算法
固定一个起点，到其他所有点最短路问题。  
基础定理1：在一个有N顶点的非负权环图中，两点之间的最短路径最多经过N-1条边。  
基础定理2：负权环没有最短路径。  
用动态规划求解最短路径，dp需要保留边数的信息。比如从0到2之间可能有多条边的情况，这时候要考虑边数，从而用动态规划进行转移。（有向图，有负权边）  
Bellman-Ford算法对于动态规划的过程进行优化，降低了空间复杂度，每一层就是只需要上一次的信息，而不需要再先前的信息。  
Bellman-Ford算法的限制：图不能包含负权环，但是可以检测负权环。
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/29/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-5/" data-id="clpjsr1bp0000jscx0g7zhn2h" data-title="算法学习-5" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法学习-4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/24/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-4/" class="article-date">
  <time class="dt-published" datetime="2023-11-24T01:35:18.000Z" itemprop="datePublished">2023-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/24/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-4/">算法学习-4</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="加工数据的数据结构"><a href="#加工数据的数据结构" class="headerlink" title="加工数据的数据结构"></a>加工数据的数据结构</h2><p>堆和二叉搜索树略过，直接从并查集开始。<br>并查集的核心思想是：查询与合并（查询两个点是否在同一个集合中）（将两个不在同一个集合的点进行合并）</p>
<p>有两种设计方法：基于id和基于parent。<br>按秩合并：结点总数较小的数的根节点指向节点总数较大的树的根节点。<br>路径压缩：两步一跳（把当前结点指向它的父亲节点的父亲节点）或者完全压缩（把查询节点到根节点沿途经过的节点都指向根节点）。</p>
<p>例题1：等式的可解性<br>给定n个方程如“a&#x3D;&#x3D;b””a!&#x3D;b”这样的形式，判定这些等式是否可解。<br>由于符号只有两种形式，也就是&#x3D;&#x3D;和!&#x3D;，因此只需要判断&#x3D;&#x3D;号两端的符号能否联通，查询!&#x3D;号两端是否联通即可。</p>
<p>例题2：省份数量<br>a城市与b城市相连，b与c相连，则abc成为一个省份。给定一个二维矩阵isConnected, isConnected[i][j]表示i和j是否直接相连。<br>如果isConnected[i][j]，就把i和j进行合并，最后只需要在parent里查询哪些变量有parent[i]&#x3D;&#x3D;i的性质。</p>
<p>例题3：情侣牵手<br>给定序列，该序列中只有数值为2i-1和2i能够成为情侣，求最少交换次数使他们成为情侣。<br>这个题目里的实际情侣对数为n&#x2F;2，
 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/24/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-4/" data-id="clpc69ci10000ggcxbojqdaq0" data-title="算法学习-4" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-《深入解析gcc》略读的一些理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/22/%E3%80%8A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90gcc%E3%80%8B%E7%95%A5%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2023-11-22T11:29:34.000Z" itemprop="datePublished">2023-11-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/22/%E3%80%8A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90gcc%E3%80%8B%E7%95%A5%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/">《深入解析gcc》略读的一些理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本着多读多看的精神读了一下这本不薄的书，还是很难理解啊。</p>
<p>或许在深入学习编译原理以后才能更深的理解其中的知识吧。</p>
<p>还是说一说编译流程：源文件(gcc可以支持的语言)$\rightarrow$AST&#x2F;GENERIC(抽象语法树)<br>$\rightarrow$ GIMPLE(gnu SIMPLE，一种中间形式，这个地方与目标平台无关，用于进行pass，编译优化等)<br>$\rightarrow$ RTL(寄存器语言，函数式类似于LISP，insn在这里对应翻译到目标平台)</p>
<p>gcc在虽然支持多种语言的前端，但是直到GIMPLE才是完全和语言无关的，这意味着想要利用gcc作为编译后端，就必须从目标语言到AST到GIMPLE都实现，这带来了很大难度。</p>
<p>如果24年的毕升杯我有能力完成Rust的完整项目，我愿意用Rust，否则我选择Java。LLVM对我还是缺少了一点实用价值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/22/%E3%80%8A%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90gcc%E3%80%8B%E7%95%A5%E8%AF%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/" data-id="clp9oy4d20000t4cxd8kig0w1" data-title="《深入解析gcc》略读的一些理解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-luarocks安装lua-sqlite报错解决" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/11/20/luarocks%E5%AE%89%E8%A3%85lua-sqlite%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/" class="article-date">
  <time class="dt-published" datetime="2023-11-20T13:29:51.000Z" itemprop="datePublished">2023-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/11/20/luarocks%E5%AE%89%E8%A3%85lua-sqlite%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/">luarocks安装lua-sqlite报错解决</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>luarocks安装是从源代码安装，因此其可能会包含一些并非系统自带的头文件。<br>luasocket为例，编译时如果出现，”lua.h”的缺失，则大概率是再lua路径下没有其源文件，最简单的方法是下载源代码，解压到该路径下。</p>
<p>luasql同理，你需要先把sqlite的源代码下载好，为其设置SQLITE_DIR和SQLITE_HOME，然后才能编译成功。</p>
<p>有些解决方法是下载xxx-dev之类的，我没有成功，所以不用这种方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/11/20/luarocks%E5%AE%89%E8%A3%85lua-sqlite%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/" data-id="clp6y6kie00003scx0fbubmhh" data-title="luarocks安装lua-sqlite报错解决" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/12/24/LinuxProcess-go%E8%BF%9B%E7%A8%8B/">LinuxProcess/go进程</a>
          </li>
        
          <li>
            <a href="/2023/12/24/LinuxProcess-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">LinuxProcess/基础知识</a>
          </li>
        
          <li>
            <a href="/2023/12/24/HTTP-day4/">HTTP/day4</a>
          </li>
        
          <li>
            <a href="/2023/12/24/HTTP-day3/">HTTP/day6</a>
          </li>
        
          <li>
            <a href="/2023/12/24/HTTP-day2/">HTTP/day2.md</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>