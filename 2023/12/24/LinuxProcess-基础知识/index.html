<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>LinuxProcess/基础知识 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="进程是什么定义已运行程序的实体，进程需要一些资源才能完成工作。进程不一定都是在运行的，也可能在等待调度。 PID全称为Process ID，是标示和区分进程的ID，他是全局唯一的正整数。在Go可以用Getpid()获得进程PID。可以看到PID是有操作系统随机分配的，同一个程序运行两次会产生两个PID。 PPID每个进程不仅有PID还会有PPID，即父进程ID。这是因为进程都是有父进程衍生出来的。">
<meta property="og:type" content="article">
<meta property="og:title" content="LinuxProcess&#x2F;基础知识">
<meta property="og:url" content="http://example.com/2023/12/24/LinuxProcess-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="进程是什么定义已运行程序的实体，进程需要一些资源才能完成工作。进程不一定都是在运行的，也可能在等待调度。 PID全称为Process ID，是标示和区分进程的ID，他是全局唯一的正整数。在Go可以用Getpid()获得进程PID。可以看到PID是有操作系统随机分配的，同一个程序运行两次会产生两个PID。 PPID每个进程不仅有PID还会有PPID，即父进程ID。这是因为进程都是有父进程衍生出来的。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-12-23T16:12:10.000Z">
<meta property="article:modified_time" content="2023-12-23T16:14:47.481Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-LinuxProcess-基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/24/LinuxProcess-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2023-12-23T16:12:10.000Z" itemprop="datePublished">2023-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      LinuxProcess/基础知识
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>已运行程序的实体，进程需要一些资源才能完成工作。<br>进程不一定都是在运行的，也可能在等待调度。</p>
<h2 id="PID"><a href="#PID" class="headerlink" title="PID"></a>PID</h2><p>全称为Process ID，是标示和区分进程的ID，他是全局唯一的正整数。<br>在Go可以用Getpid()获得进程PID。<br>可以看到PID是有操作系统随机分配的，同一个程序运行两次会产生两个PID。</p>
<h2 id="PPID"><a href="#PPID" class="headerlink" title="PPID"></a>PPID</h2><p>每个进程不仅有PID还会有PPID，即父进程ID。<br>这是因为进程都是有父进程衍生出来的。PID为1的进程是内核创建的init进程，所以该进程没有父进程。<br>Go有Getppdi()  </p>
<h2 id="使用PID"><a href="#使用PID" class="headerlink" title="使用PID"></a>使用PID</h2><p>查看进程的PID可以用top&#x2F;ps</p>
<h3 id="TOP"><a href="#TOP" class="headerlink" title="TOP"></a>TOP</h3><p>可以看到当前的进程，并获取更具体的PID</p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h3><p>执行ps aux</p>
<h2 id="使用PID-1"><a href="#使用PID-1" class="headerlink" title="使用PID"></a>使用PID</h2><p>有了pid就可以用kill结束进程。  </p>
<h1 id="进程名字"><a href="#进程名字" class="headerlink" title="进程名字"></a>进程名字</h1><p>进程名是进程参数的第一个字符串，一般可以用os.Args获取。  </p>
<h1 id="进程参数"><a href="#进程参数" class="headerlink" title="进程参数"></a>进程参数</h1><p>任何进程启动时都可以赋予一个字符串数组作为参数，一般叫Argv或Args。  </p>
<h2 id="获得进程Argument"><a href="#获得进程Argument" class="headerlink" title="获得进程Argument"></a>获得进程Argument</h2><p>进程参数可以分两类：Argument(参数)也就是作为进程运行的实体参数。<br>Go可以用os.Args获取命令行参数，即os.Args[1:]就是所需输入的。  </p>
<h2 id="获得进程flag"><a href="#获得进程flag" class="headerlink" title="获得进程flag"></a>获得进程flag</h2><p>使用Flag可以将命令行参数转化成所需要的数据类型</p>
<h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><h2 id="进程输入与输出"><a href="#进程输入与输出" class="headerlink" title="进程输入与输出"></a>进程输入与输出</h2><p>每个进程，操作系统都会分配三个文件资源，分别是标准输入STDIN，标准输出STDOUT，错误输出STDERR。  </p>
<h2 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h2><p>来自管道的数据也是标准输入的一种。这就可以用io.Readall来获取。</p>
<h2 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h2><p>fmt.Printxx</p>
<h1 id="Concurrently-Parallel"><a href="#Concurrently-Parallel" class="headerlink" title="Concurrently Parallel"></a>Concurrently Parallel</h1><p>这两者是不同的概念，并行是实现并发的一种。</p>
<h1 id="进程越多越好？"><a href="#进程越多越好？" class="headerlink" title="进程越多越好？"></a>进程越多越好？</h1><p>Nginx是一个高性能、高并发的Web服务器,也就是说它可以同时处理超过10万个HTTP请求,而它建议的启动的进程数不要超过CPU个数,为什么呢?<br>Nginx是Master-Worker模型，Master进程只管负责Worker进程，worker进程负责处理真实的请求。每个worker进程能够处理的请求跟内存有关，因为Linux的Nginx使用了epoll这样的多路复用的IO接口，不需要多线程并行也能并发。<br>多进程的快出是CPU切换上下文时间变多。  </p>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>进程数等于CPU数，但是进程有阻塞。这是应该提高进程数增加并发数。<br>在Nginx的例子中,如果Nginx主要负责静态内容的下载,而服务器内存比较小,大部分文件访问都需要读磁盘,这时候进程很容易阻塞,所以建议提高下Worker数目。 </p>
<h1 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h1><p>nginx可以在配置文件里面知名COU，减少上下文切换。  </p>
<h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p>在Linux源码fs&#x2F;proc&#x2F;array.c里面，定义了7种状态。</p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>O:进程正在处理器运行,这个状态从来没有见过.<br>S:休眠状态(sleeping)<br>R:等待运行(runable)R Running or runnable (on run queue) 进程处于运行或就绪状态<br>I:空闲状态(idle)<br>Z:僵尸状态(zombie)<br>T:跟踪状态(Traced)<br>B:进程正在等待更多的内存页<br>D: 不可中断的深度睡眠,一般由IO引起,同步IO在做读或写操作时,cpu不能做其它事情,只能等待,这时进程处于这种状态,如果程序采用异步IO,这种状态应该就很少见到了。 </p>
<h1 id="退出码"><a href="#退出码" class="headerlink" title="退出码"></a>退出码</h1><p>人和进程退出是都会留下退出码。0-255.0表示正常退出。<br>这个东东在bash脚本很常见，根据前一个命令的退出吗选择是否执行下一个</p>
<h1 id="进程资源"><a href="#进程资源" class="headerlink" title="进程资源"></a>进程资源</h1><p>查看PID为1的进程信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /proc/1/</span><br></pre></td></tr></table></figure>
<p>同样的可以在这里查看&#x2F;proc&#x2F;1&#x2F;status</p>
<p>实际上ps命令获得的数据就是查看proc文件夹的内容获得的</p>
<h1 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h1><p>一个进程拿着资源A请求资源B，另一个进程拿着资源B请求资源A，双方都不释放自己的资源，导致两个进程都进行不下去。  </p>
<h1 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h1><p>进入活锁的进程是没有阻塞的，会继续使用CPU，但外界看到整个进程没有进行。  </p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>两个人同时过独木桥，两个人都让对方，这就是活锁<br>活锁会导致CPU耗尽，解决方法是引入随机变量、增加重试次数等。  </p>
<h1 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h1><p>Portable Operation System Interface</p>
<p>操作系统的接口标准，Unix, Linux, Mac遵循这套标准。  </p>
<h2 id="POSIX进程"><a href="#POSIX进程" class="headerlink" title="POSIX进程"></a>POSIX进程</h2><p>有POSIX定的fork和exec创建起一个POSIC进程，这个进程可以使用通用的IPC，信号等机制。  </p>
<h2 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h2><p>POSIX定义了线程的标准，包括创建和控制线程的API，在pthreads中实现</p>
<h1 id="Nohup"><a href="#Nohup" class="headerlink" title="Nohup"></a>Nohup</h1><p>普通进程运行时会默认绑定在TTY，关闭后会给上面的所有线程发送TERM信号。<br>Nohup原理就是在此终端关闭时给该终端下的每一个进程发送SIGHUP信号，但是nuhup会忽略这个信号。<br>这是运行守护进程最简单的方法。</p>
<h1 id="运行进程"><a href="#运行进程" class="headerlink" title="运行进程"></a>运行进程</h1><p>系统调用，利用系统提供的fork和exec接口</p>
<h1 id="衍生新进程"><a href="#衍生新进程" class="headerlink" title="衍生新进程"></a>衍生新进程</h1><p>可以类比erlang的spawn，能够执行任意go或者非go程序，等待返回结果，外部进程结束后继续执行本程序。<br>go提供了eexec.Command来执行其他程序。  </p>
<h1 id="执行外部程序"><a href="#执行外部程序" class="headerlink" title="执行外部程序"></a>执行外部程序</h1><p>把新程序加载到自己的内存里。<br>执行外部程序不会返回到原进程中。<br>应用的机制是syscall这个包</p>
<h1 id="复制进程"><a href="#复制进程" class="headerlink" title="复制进程"></a>复制进程</h1><p>go没有提供复制父进程的堆栈空间的接口，事实上spawn, exec都是调用的Fork</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/24/LinuxProcess-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="clqi9htlh0001u0cxfe4qclef" data-title="LinuxProcess/基础知识" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2023/12/24/LinuxProcess-go%E8%BF%9B%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          LinuxProcess/go进程
        
      </div>
    </a>
  
  
    <a href="/2023/12/24/HTTP-day4/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">HTTP/day4</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">September 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/12/24/LinuxProcess-go%E8%BF%9B%E7%A8%8B/">LinuxProcess/go进程</a>
          </li>
        
          <li>
            <a href="/2023/12/24/LinuxProcess-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">LinuxProcess/基础知识</a>
          </li>
        
          <li>
            <a href="/2023/12/24/HTTP-day4/">HTTP/day4</a>
          </li>
        
          <li>
            <a href="/2023/12/24/HTTP-day3/">HTTP/day6</a>
          </li>
        
          <li>
            <a href="/2023/12/24/HTTP-day2/">HTTP/day2.md</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>